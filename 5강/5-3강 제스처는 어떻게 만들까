Okay so let's go back to the slides and talk a little bit about gestures

좋아, 슬라이드로 다시 돌아가서 제스처에 대해서 알아보자

and then we'll come back and add some gestures to our face right here?

그리고 돌아와서 실제로 우리 얼굴에 제스처를 넣어볼꺼야

Okay. so we saw last time how to draw in a view.

우리는 마지막 시간에 뷰에서 어떻게 그리는지 배웠지

We drew the mouth, we drew the eyes, we did the eyebrows

우리는 입이랑, 눈이랑, 눈썹을 그렸고

all these things we know how to do that pretty much right.

이제 어떻게 하는지에 대해 대충 감은 잡힐꺼야

We use UIBezierPath in our drawRect, not too hard.

우리는 drawRect에 UIBezierPath를 사용했어, 어렵지 않지

What about gestures? Okay?

하지만 제스처는 어떨까?

So this is input from the user on the screen.

자, 제스처라는 것은 화면을 통해 전달된 유저의 입력이야

Now, we can get the location and movement of every single finger

우리는 화면 위에 올려져 있는 모든 손가락의 위치와 운동을 알 수 있지

that touches down on the screen that's possible okay?

이건 가능해

There is an API for doing that but, we virtually never do that ever.

이걸 해주는 API도 있지만 절대로 사용하지는 않지

Why don't we do that?

왜 사용하지 않을까?

The reason for that is that the user thinks of interacting with your UI

그 이유는 사용자는 너의 UI를 터치하는 방법이

as a gesture like they're swiping or they're pinching okay?

스와이프나 핀치등, 하나의 제스처의 단위기 때문이야

or they're panning around. Those are gestures that they are making

아니면 팬라든지. 이것들은 모두 제스처야

so iOS has an abstraction layer that lets you app think of the input

따라서 iOS에는 이것들을 제스처로 인식할 수 있는 추상화 레이어가 존재해

as gestures as well, okay? So, you're gonna get those gestures

따라서 미리 정의되어 있는 이 제스처들이 발생하는지 확인되면

and do somthing when they happen there's predefined gestures.

앱 내에서 무엇을 하면 되는거야

The great thing about that is a swipe is exactly the same thing

이 방법의 좋은 점은 스와이프는 모든 앱에서 같은 것으로 인식된다는 것이야

in every single app. Okay? It's like you know the speed of swiping

예를 들어 스와이프 하는 속도라든가

and how far you have to swipe, all that's exactly the same in

얼마나 멀리 스와이프 하는가 등은 모든 앱에서 똑같이 인식되는거지

every single app because every single app is using these gestures, okay?

왜냐하면 모든 앱들은 제스처를 사용하기 때문이야

If you had to do you're own swipe, you know did the person swipe fast enough?

만약 너가 스와이프를 직접 구현해야 했다면, 어떻게 사용자가 충분히 빨리 스와이프 했는지 체크할까?

or was that a pan? you have to do all that logic yourself would be a pain

혹은 이것이 팬인지 어떻게 체크할까? 이 모든 로직을 직접 구현해야하고

in the neck and will be inconsistent between applications okay?

그렇게 직접 구현하는 것은 귀찮고 어려울 뿐만 아니라 앱 사이들에 일정하지 못할거야

So, gestures are recognized, by instances of a class called UIGestureRecognizer

좋아. 제스처는 iOS에서 UIGestureRecognizer의 인스턴스들에 의해 인식돼

okay? Good name, but UIGestureRecognizer itself is abstract.

좋은 이름이지만, UIGestureRecognizer는 사실 abstract한 클래스야

You never actually instantiate one instead there are a bunch of subclasses of

UIGestureRecognizer를 절대 생성할 일은 없지만 이것을 상속받는 클래스들은 여럿 있지

UIGestureRecognizer and those are what you instantiate to get the kind of gestures you want.

이 상속받은 서브클래스들을 생성해서 제스처를 인식하는거야

So there's pan gestureRecognizer and pinch gesture Recognizer

따라서 팬를 인식하는 PanGestureRecognizer, 핀치를 인식하는 PinchGestureRecognizer

and tap and swipe gesture recognizer etc, okay?

그리고 탭, 스와이프를 인식하는 TapGestureRecognizer, SwipeGestureRecognizer등등이 있지

Now when you want to use a recognizer there's really two parts to it, okay?

Recognizer 클래스를 쓰려면 2가지를 알아야해

One, you have to get some UIView to take on this gesture recognizer and recognize that gesture.

첫번째, 어떤 UIView객체가 이 Recognizer를 받아서 해당하는 제스처를 인식할 수 있게 해야해

So there's the gesture recognition part which is done by creating a gesture recognizer and then asking a view to use it.

따라서 제스처 인식파트는, GestureRecognizer를 생성한 뒤에 View에게 이 GestureRecognizer를 사용하도록 하는거야

Only views can recognize gestures not controllers.

컨트롤러는 인식할 수 없고, 오로지 View만 제스처를 인식할 수 있어.

They can't recognize only views, okay?

컨트롤러는 제스처를 인식할 수 없어. 오로지 View들만이야

So part one is to create the gesture recognizer you want,

따라서 첫번째 파트는, 원하는 GestureRecognizer를 생성하고

configure it how you want, and ask some view, please start recognizing this, okay?

원하는대로 설정한 뒤에, 어떤 뷰에게 제스처를 인식해달라고 묻는 거야

Then part two is, what if the recognizer does recognize it?

그리고 두번째 파트는, 만약 그 제스처가 인식되었다면?

Then it needs to have that handled somehow and that's done with a gesture handler.

그렇다면 이것이 처리되어야하고, 이 처리하는 것은 GestureHandler가 담당해

So you got recognizers and gesture handlers okay?

따라서 GestureRecognizer가 있고 GestureHandler가 있는거야

And the handler is called as the recognizer goes through a basically

GestureHandler는 GestureRecognizer가

a state machine of recognizing this gesture.

해당하는 제스처를 인식하는 과정의 상태머신의 과정에서 호출돼

We'll talk about what that state machine looks like

이 상태머신이 어떻게 생겼는지는 조금 이따가 설명하겠지만

but it's gonna be called repeatedly.

GestureHandler는 계속 되풀이 되서 호출될거야

The handler's gonna be called repeatedly as gesture goes through

GestureHandler는 제스처가 인식되는 과정부터

the process of being recognized and moving and all the things it does, okay?

특정한 것을 움직이거나 액션을 취해지는 동안 계속 반복적으로 호출될꺼야

Now usually the first of these things

자 이것들은 첫번째 과정인

the creating of a recognizer and adding it to some view,

GestureRecognizer를 생성하고 어떤 뷰에다 넣는 과정은

its usually done by your controller.

일반적으로 컨트롤러에서 처리돼

It doesn't have to be done by your controller,

컨트롤러에서 굳이 이걸 할 필요는 없지만,

but it's a good way for your controller to essentially turn on that gesture in one of it's views okay?

컨트롤러에서 특정한 뷰에 제스처를 인식하도록 하는 좋은 방법이야

The views are the minion of the controller anyway so

뷰들은 어차피 컨트롤러의 부하들이야

the controller wants to control its minions so it might usually be

컨트롤러는 당연히 부하들을 관리하고 싶기 때문에 일반적으로

the one that wants to add the gesture recognizer to the view, but some views, the

컨트롤러가 GestureRecognizer를 뷰에다 넣는 역할을 담당하지만, 어떤 뷰들은

gesture recognition is so fundamental to who they are, that they added them themselves.

제스처 인식이 핵심 기능을 담당하고 있는 뷰들은 자체적으로 GestureRecognizer를 넣어줘

For example, scrollView, okay? What would a scrollView be without a pan gesture to scroll up and down?

예를 들어, scrollView를 들어보자. scrollView에 위아래로 팬 해서 스크롤 할 수 있는 기능이 없으면 무엇일까

it would be useless.

쓸모가 없겠지

It wouldn't even be a scrollView anymore

더이상 scrollView도 아닐꺼야

so scrollView adds a pan gesture recognizer and a pinch gesture recognizer to itself.

따라서 scrollView는 자체적으로 PanGestureRecognizer과 PinchGestureRecognizer를 자기 자신에 더해

Probably in its initializer okay?

아마도 생성자에 넣어둘꺼야

But lot of the times it's your controller that's adding the gesture

하지만 대부분의 경우에 컨트롤러에서 GestureRecognizer를 넣어주지

again,  the controller can't do the recognition of a gesture,

다시 말하지만, 컨트롤러는 제스처를 인식할 수 없어

only a view with a gesture recognizer can

오로지 GestureRecognizer를 가지고 있는 뷰만 할 수 있지

but the controller can add that gesture recognizer

하지만 컨트롤러는 GestureRecognizer를 뷰에 넣어줄 수 있어

create and add the gesture recognizer to one of its views in its view okay?

소속되어 있는 뷰에 GestureRecognizer를 생성해서 넣어줄 수 있는거지

The second thing that handler, that handles it?

두번째로 처리를 담당하는 Handler는

Well that could be handled by the controller, or it might be handled by the view,

이건 컨트롤러에서 처리할 수도 있고, 뷰에서 처리할 수도 있어

could even be handled by someone else

아니면 아예 다른사람이 처리할 수도 있지

would never be handled by a model because UI independent

UI와 독립된 구조이기 때문에  절대로 모델에서는 이걸 처리할 수는 없어

but it could be anyone in the controller or view camps can handle it.

하지만 View나 Controller들 중 하나가 처리할 수 있는거지

Generally, kind of, it the thing that the gesture is doing is only modifying

일반적으로, 만약 제스처가 하는 일이 유일하게

how the view displays itself, like in our face view,

우리의 얼굴 뷰처럼 뷰가 어떻게 보이는지를 바꾸는 거라면

it was just the scale of the view or maybe somehow it's chaning the color of the view,

예를 들어 뷰의 비율을 바꾼다던가, 색상을 바꾼다던가라면

then the view is probably going to handle the gesture. Okay?

뷰가 자체적으로 그 제스처를 처리할거야

Its going to both recognize it with the recognizers and handle it.

뷰는 Recognizer로 인식을 한뒤 처리할거야

But if the gesture's changing the model then definately the controller would be the handler.

하지만 만약 제스처가 모델에 직접적인 수정을 가한다면, 당연히 컨트롤러에서 이 제스처를 처리하게 될거야

You see why that is?

이해하겠어?

Because the view can't see the model. Okay? But the controller can.

뷰는 모델을 볼 수 없기 때문이지. 하지만 컨트롤러는 볼 수 있어

So the controller would set it self as the recognizer of anything that's going to affect the model.

따라서 컨트롤러는 모델에 영향을 미치는 어떤 제스처이든지에 대해서 처리를 할거야

And we'll see that in the demo as well. Okay.

그리고 우리 데모에서도 이게 나올거고

So how do we add a gesture t UIView?

어떻게 GestureRecognizer를 UIView에 넣을 수 있을까

We decided we want a view in this case let's say to recognize pan okay?

우린 예시로 손가락으로 팬하는 제스처를 인식하는 뷰를 원한다고 해보자

A pan is putting your finger down on the screen and moving it around without lifting it up.

팬(Pan)이란, 화면 위에 손가락을 올려놓고 떼지 않은채로 움직이는 걸 말해

When you lift it up, the pan is over. Okay?

손가락을 때버리면, 그때 팬 제스처는 끝나버리는 거야

That's what a pan is, basically panning your finger around on the screen.

이게 팬(Pan)이야, 화면 위에 손가락을 팬하는거지

Alright? So what if we wanted to do that?

아까 말한 뷰를 원한다면 어떻게 해야할까?

Well one place so we have to somewhere in our controller code add a pan gesture recognizer

그렇다면 첫번째로, 컨트롤러 코드 어딘가에 PanGestureRecognizer를

to the veiw that we want the paninng to happen in okay?

팬 제스처가 발생하는 뷰에 넣어줄 수 있는 코드를 넣어야해

Well a great place to do that is in that didSet okay?

이 코드를 넣기에 매우 좋은 장소는 outlet의 didSet 구문 안이야

of the outlet because as soon as that view we want to pan, as soon as we get a pointer to it,

왜냐하면 팬하고 싶은 뷰를 가지자마자, 그것의 포인터를 가지자마자

let's immediately just add the gesture recognizer right there okay?

그곳에서 바로 PanGestureRecognizer를 넣어버리는거지

nd we know that this didSet right her. Okay we already saw this in the demo I just did

그리고 우리는 이 didSet 메소드가 내가 했던 데모로 부터

this didSet when you're doing it to an outlet this gets called only once.

어떤 outlet에 didset메소드를 적용하면 오로지 한번 호출되고

It gets called when iOS first hooks up that view.

iOS가 처음 이 뷰를 연결시킬 때 호출이 되지

Perfect time to go add a gesture recognizer okay? So we're gonna do that.

GestureRecognizer를 넣기 완벽한 타이밍인거지. 따라서 이걸 하는 방법은

First, we are going to create the pan gesture recognizer, okay?

첫번째로, PanGestureRecognizer를 생성할거야

Here's a concrete subclass of UI gesture recognizer called PanGestureRecognizer,

여기에 UIGestureRecognizer를 상속받는 concrete한 서브클래스인 PanGestureRecognizer가 있어

it takes two arguments here, the first is who is going to handle this gesture when I recognize it.

2가지 인자를 받은데, 첫번째는 제스처를 인식을 하면 누가 처리를 할건지에 대한 것이야

So this pangesture recognizer is saying hey if I recognize a pan, who's going to handle it form me.

따라서 이 PanGestureRecognizer가 하는 말은 팬를 인식하면, 누가 이것을 처리해줄 것인가야

The answer is self, so that's the controller. Okay?

이것의 답은 self야. 그리고 그건 컨트롤러이지

This is an outlet in the controller, so the tartget self means that controller is going to handle this pan itself. Okay?

이건 컨트롤러에 있는 outlet이고 self를 타겟한다는 것은 컨트롤러가 자체적으로 이 팬 제스처를 처리한다는 뜻이지

The second argument here, is what method do you want me to invoke in self when this gets recognized.

여기있는 두번째 인자는, 제스처가 인식되면 self 클래스 내부에 어떤 메소드를 호출할 것인지야

Now there's some kind of funky syntax here, this has to be an objective-C runtime compatible selector okay?

여기는 특이한 코드 형식이 쓰이는데, 여기에는 Objective-C 런타임 호환 Selector가 쓰여야해

That just means a selector, a method that is visible to the objective-C runtime

이건 그냥 Objective-C 런타임에 보이는 메소드인 selector를 의미해

now for this to be visible to runtime, this method must be in a class inherits from NSObject.

Objective-C 런타임에 보이는 메소드일려면, 이 메소드는 NSObject를 상속받는 클래스의 메소드여야해

Remember I was talking about that NSObject thing, and sometimes you're going to need it, well here you would need it.

예전에 NSObject를 설명하면서 어쩔때는 필요하다고 했었지? 이때가 필요한 때야

Now you won't usually care about that here,

여기에는 일반적으로 신경을 쓰지 않아도 돼

because this is almost always being handled by either a UIViewController which definately inherits from NSObject, or a UIView,

왜냐하면 제스처를 거의 항상 NSObject를 상속받는 UIViewController나,

which definately inherits from NSObject right? So usually don't care. Okay?

NSObject를 상속받는 UIView가 처리하기 때문이야. 따라서 일반적으로 신경쓰지 않아도 돼

Not usually going to be trying to send this to some object that's a swift object that doesn't inherit from NSObject.

NSObject를 상속받지 않는 Swift 오브젝트에 이 처리를 보낼일은 아마 없을꺼야

but this syntax here means create an objective-C compatible selector. Okay?

여기 이 형식은 Objective-C에 호환되는 Selector를 생성하라는 뜻이야

Selector just means kind of identifiers for method

Selector는 메소드를 판별할 수 있도록 되어있는 판별자란 뜻이야

and here is just a class, a . and then the name of the method including the argument names. Don't forget the argument names.

그리고 여기에는 클래스 이름, 그리고 마침표, 그리고 메소드 이름과 함께 인자 이름을 넣어줘야해. 인자이름을 까먹지 않도록해

Now this pan method that I'm going to show you on the next screen, it has one argument

여기 있는 pan메소드는 다음장에 보여줄건데 하나의 인자를 가지고 있어

that argument is the pan gesture recognizer.

그 인자가 PanGestureRecognizer야

So just like when we have target action and we have a button that has the sender is sending itself, same thing here.

따라서 target action에서 했듯이, 우리가 버튼을 가지고 있고 그것이 sender라는것을 가질때 그 자신을 보내는것과 마찬가지야

When we have a pan gesture recognizer and it starts to recognize,

PanGestureRecognizer가 제스처를 인식하기 시작하면,

it sends this pan method here to the view controller with itself as the argument.

그것은 여기 pan 메소드를 컨트롤러에게 자기 자신을 인자로 넣고 보내주지

Now you might say why is this underbar right here.

여기에 왜 언더바가 들어가는지 물어볼 수도 있어

Why don't I have the name of whatever this first keyword is

왜 여기에 첫번째 인자 이름이 들어가지 않냐고 물어볼 수 있어

and that's because I don't really care what that name is, I just want to

왜냐하면 신경을 쓰지 않기 때문이야

make it clear I want the version of pan that has one argument.

pan 메소드 중에 하나의 인자를 가진 녀석만 보내고 싶다는걸 명시해주고 싶은거지

Now if I had multiple pan methods, that had differenet first names there,

만약 내가 여러개의 pan 메소드를 가지고 있고 인자이름이 다르다면

then I would have to put the name in there.

여기에 인자이름까지 명시해줘야겠지

But I can put underbar here, because underbar in Swift means; I don't care whatever. Okay?

하지만 나는 여기에 언더바를 넣을 수 있어, 왜냐하면 스위프트에서 언더바는; 신경쓰지 않는다이기 때문이야

I don't really care what it is, its a substitute for I don't care.

뭐인지 신경쓰지도 않고싶다는거야, 신경쓰지 않는다의 대체재야

But I don't really care. I just want to introduce that you can do this underbar here

그래서 신경쓰지 않아. 여기 언더바를 쓸 수 있다는걸 알려주고 싶었어

but if I don't put this colon and underbar here then it's gonna try to call a pan method that has no arguments so be careful.

하지만 여기에 콜론과 언더바를 을 넣어주지 않는다면 인자가 없는 pan 메소드를 호출할려고 할 것이기 때문에 주의해야해

If you want the one with the gesture recognizer as an argument you gotta put that in there. Okay?

만약 너가 GestureRecognizer가 인자로 있는 pan 메소드를 원한다면 거기에 그렇게 명시해줘야해

So that's specifying the selector.

이게 Selector를 명시해주는거야

And then I just turn on this recognizer by taking the view, this is the UIView this pannable view, okay?

그리고 나는 이 Recognizer를 활성화해주는데, 이 뷰를 가지고

And adding this, thing I created, as a gesture recognizer okay?

만들어진 Recognizer를 뷰에다가 더해주면 끝나

As soon as I do that, this view is going to start recognizing pan gestures okay?

이걸 실행하자마자, 이 뷰는 팬 제스처를 인식하기 시작할꺼야

And when it does, its gonna send this method, to self, which is the controller.

그리고 인식이 되면, 여기 있는 이 메소들를 self, 즉 컨트롤러에게 보낼꺼야

Got it? Okay. Make sense? Alright so now lets talk about how we implement this handler.

자 이제 어떻게 Handler를 구현할건지 알아보자

This method right here this pan thing. Okay?

여기 있는 이 pan 메소드 말이야

What does that look like to implement.

이 메소들를 구현할려면 어떻게 해야할까?

To understand how we're going to implement such a method

이 메소들을 어떻게 구현할지 이해하려면 먼저

we need to understand a little bit more about the contrete subclasses of UIGestureRecognizer

UIGestureRecognizer의 concrete한 서브클래스들을 더 이해를 해봐야할거야

so let's look at pan. Okay?

팬 제스처를 보자.

So pan, UIPanGestureRecognizer, it has a few methods on it that are specific to panning, okay?

UIPanGestureRecognizer에는 팬 제스처에 특별한 몇가지 메소드 들이 있어

For example, it has translation in view.

에를 들어 UIPanGestureRecognizer에는 translationInView이라는 메소드가 있어

It takes a UIView and tells you how far the pan has moved in that views coordinate system okay?

이 메소드는 UIView를 인자로 가지고 팬이 뷰의 좌표내에 얼마나 움직였는지를 알려줘

Which is exactly what you want for pan because you wanna know where you are so you can know how far you moved.

이건 팬에 꼭 필요한 기능이지 왜냐하면 얼마나 멀리 움직였는지 알야하기 때문에

It even has veloctiy and it will tell you how fast the pan is happening okay?

UIPanGestureRecognizer는 심지어 velocityInView라는 메소드가 있는데 이건 팬이 얼마나 빨리 진행되는지를 알려줘

If you're ripping it around versus going really really really slow

만약 엄청 빨리 팬을 하거나 매우 늦게 팬을 하는지 확인할 수 있어

like you're in a drawing app you might be really slow you might be going really carefully

예를 들어 그림을 그리는 앱이라면 매우 천천히 팬을 하겠지

and if you're zipping around now you're making big arcs or something who knows.

그리고 빠르게 팬을 하면 크게 곡선을 그리는 식으로 처리를 할 수 있을꺼야

And it even has setTranslation which is setting this.

여기에는 심지어 translation 값을 지정해주는 setTranslation이라는 메소드도 있어

Why would you ever want to set this? Well, if you don't set this okay?

이걸 왜 설정해줘야할까? 만약 이걸 설정해주지 않는다면

Then this translationView is going to be the cumulative translation in view. Okay?

translationInView 메소드는 이 뷰에서의 누적한 이동거리일거야

It's how far the pan has moved since it started the cumulatitive thing.

팬 제스처의 처음부터 쭉 누적된 값을 받는거지

It you what you want instead is how much it changed since last time you told me about it, okay?

만약 이 값 말고 마지막 읽었을때부터 얼마나 값이 변했는지를 보려면,

You can constantly reset this thing to 0.

이 값을 지속적으로 0으로 설정해주면 돼

If you constantly reset this translation to 0 then the next time you get it, it's going to be the translation incremental okay?

만약 지속적으로 0으로 설정해주면 다음번에 translationInView를 호출하면 이동거리의 변화량을 구할 수 있을꺼야

Tiny liitle tiny bit it moved since the last time.

마지막 움직인것에 작은 양만큼 변화한 값이지

So you'll see in the demo that we will reset this to 0 every time because we just want the incremnetal panning. Okay?

데모에서 이걸 지속적으로 0으로 설정해서 팬의 변화량을 확인하는걸 볼꺼야

All right? So, the abstract super class of your  UIPanGesture also provides a very important VAR which is the state.

UIPanGesture의 부모클래스인 abstract 슈퍼클래스는 매우 중요한 변수인 state를 가지고 있어

Okay? I told you these gesture recognizers goes through a state machine and this is how you can find out in your handler,

내가 말했듯이 GestureRecognizer들은 상태머신의 형태를 가지고 있고 이러기 때문에 핸들러에서

what state the gesture is it.

제스처가 어떤 상태에 있는지 확인할 수 있어

So they all start around in this state possible.

모든 GestureRecognizer들은 .Possible이라는 상태에서 시작해

Okay? UIGestureRecognizerState . possible.

UIGestureRecognizerState.Possible 이야

Then, for a discrete gesture like a swipe once the swipe happens, it immediately goes to the state recognized. Okay?

그리고, 스와이프 같은 불연속적인 제스처에는, 스와이프가 발생하면 바로 .recognized로 상태가 바뀌어

It recognized the swipe. So you're handler gets called. The state will be recognized.

스와이프를 인식한거야. 그래서 Handler가 호출되지. 이 상태도 인식될거야

For a continuos gesture like a pan or a pinch, okay?

팬이나 핀치같이 연속적인 제스처에 대해서는

It goes to the state began as soon as the pan gets held down

팬이 눌리는 순간부터 바로 .Began이라는 상태로 가고

and as soon as the pan starts moving, it keeps going to the state changed

팬이 움직이는 순간부터 .Changed라는 상태로 바뀌어

Changed, changed, changed the handler keeps getting called over and  over and over and over with changed okay?

계속 핸들러가 .Changed의 상태로 호출돼

And everytime, this tranlation is chaning okay?

그리고 매번 이 translation 값은 변하게 되어있어

And then when the finger goes up, then it goes to ended. Makes sense?

그리고 손가락이 화면에서 떼어지면, .Ended 상태로 가게 돼

Now there's a couple other states here failed and cancelled like if you're doing

소개하지 않은 상태 2개 정도가 있는데, .Failed와 .Cancelled야

the middle of a pan and a phone call comes in okay?

예를 들어 팬을 하는 도중에 전화가 걸려온다면

Then your gesture is going to get canceled. Okay?

유저의 제스처는 .Canceled될꺼야

So you might or might not have to deal with that.

따라서 그걸 처리해 줘야 할수도 있지

If you're dealing with your pan incrementally, then who cares if it gets interrupted?

만약 팬의 증가분을 보고 있다면, 팬이 중단되었는지 알 필요가 없어

You were moving the thing incrementally.

팬의 증가분을 보고 있었기 때문이지

If you're dealing with out pan with some big thing at the end when

만약 팬이 끝날때 무언가를 처리해야한다면

the pan ends, then you better do in here what you're going to do when it ended. Okay?

.Ended 처리가 될때 이 일을 처리하면 될거야

But a lot of times you don't care because you're doing all the work in change so

하지만 많은 경우에는 신경 쓸 필요가 없어 왜냐하면 모든 일은 .Change에서 이루어지고 있기 때문이지

cancelled and failed is just like ended but you don't notice the finger doing up.

따라서 .Cancelled 와 .Failed는 .Ended과 같지만 손가락이 떨어지는 걸 감지하지 못한것이지

Well, no big deal. Okay? So now that I have all this information about an pan gesture

중요하지 않아. 자 이제 나는 팬 제스처에 대한 정보를 다 알고 있어

how do I make a handler that handles a pan gesture? Okay?

이제 어떻게 핸들러가 팬 제스처를 처리하도록 할까?

This is what the code would look like,

이게 그 코드야

this code is going to be in my controller because I said the controller is

이 코드는 컨트롤러 안에 들어가게 될거야 왜냐하면 컨트롤러가 팬 제스처를 처리할것이기 때문이야

going to handle the pan and first I'm going to look at the state. Okay?

첫번째로 상태를 볼건데

Of the  Okay. Yeah Sorry. Here's that pan underbar colon you see this pan takes an argument

이게 아까 그 언더바 콜론을 가지는 팬 메소드야

Okay? Instead of underbar there I could have put gesture, because that's wha they called it here, gesture.

아까 언더바 대신에 gesture라는 인자 이름을 넣어줄수도 있었었어, 왜냐하면 여기서 그렇게 불리기 때문이지

But I don't care but this one takes an argument.

하지만 하나의 인자를 가지기 때문에 신경쓰지 않아

You could have pan with no arguments here and nothing there,

여기서 아무 인자도 없는 pan 메소드를 가질 수 있지,

and this would not pass the pan gesture along as an argument

그리고 이 메소드는 팬 제스처를 인자로 넘기지 않을꺼야

but here I need the pan gesture becasue I need to know how far the pan has gone

하지만 나는 팬이 얼마나 움직였는지 알아야하기 때문에 팬 제스처가 필요해

Okay? So next I'm going to switch on the state that the pan gesture is in,

다음으로 나는 스위치를 써서 팬 제스처가 어떤 상태에 있는지 확인할거야

and if it's changed, or ended, then I'm going to update somthing in my controller.

그리고 만약 제스처가 .Changed나 .Ended 되었다면 나의 컨트롤러에서 무언가를 업데이트 할거야

Otherwise, I'm gonna ignore it.

그게 아니라면 무시해버릴거야

Okay? If it's cancelled or failed or if it began, I don't care.

만약 .Cancelled나 .Failed나 .Began 상태라면 나는 신경쓰지 않을꺼야

I'm only interested when it moves. Okay?

나는 이 제스터가 움직일때만 관심이 있거든

So that's why I'm only looking at this now

그래서 이 상태를만 보는거야

I wanna show you this kind of cool thing in switch hopefully you've got this in you'r homework

여기서 스위치의 신기한 기능을 보여줄건데, 과제에 이게 포함되어있었으면 좋겠어

but there's this thing fallthrough, remember that Swift cases don't fallthrough to the next case as they do in C.

여기서 fallthrough라는게 있는데, 스위프트의 스위치는 C처럼 다음 케이스로 fallthrough 하지 않아

Okay? But you can force them to fall through with fallthrough.

하지만 fallthrough라는 명령어로 강제로 fallthrough하게 할 수 있지

Now I probably wouldn't write code like this, I would just say case .Changed, .Ended

아마 이런 코드를 쓰는것 보다 .Changed, .Ended라고 하는게 더 나을것야

Okay? That's easier way to do this but I just wanted to show you fallthrough.

그게 더 쉬운 방법이지만 fallthrough를 보여주기 위해 이렇게 짰어

Okay? All right? So here, inside, when things haved changed or ended,

자 여기 안에서, 만약 .Changed 거나 .Ended일 경우에

I'm going to get the translation in the pannableView.

PannableView의 translation(이동거리)를 구할거야

Remember this is that outlet, I'm gonna get that translation from the gesture.

이게 outlet인것을 기억해. 나는 translation은 제스처로 부터 구할거야

And then I'm gonna go and update something that depends on where the pan is

그리고 팬이 어디에 있는지에 따라 의존적인 무언가를 업데이트 할거야

I've got, I know where the pan, how far it has moved,

팬이 얼마나 움직였는지 알기때문에,

so I'm just going to update what something that needs that

이 정보가 필요한 무언가를 업데이트 할거고

and then I'm going to set the translation back to zero. Okay?

그리고 translation을 다시 0으로 설정해줄꺼야

It also could be CGPoint .0 if you want but I'm going to set it back to zero

이건 CGPoint.0일 수도 있지만, 0으로 설정해줄꺼야

so the next time I get called my handler, next time it comes around, this translation will be the

따라서 핸들러가 호출되는 다음번엔, 이 translation값은

incremental translation from the last time it sent it to me.

마지막 호출된때로 부터 변화한 값의 변화량을 보는거지

Everybody get that? Okay? Alright, so that's it. That's what the handler looks like.

이게 핸들러를 구현하는 방법이야

Pretyy straightforward. Okay. We'll see this in the demo, it's not too bad. Okay?

직관적이지. 데모에서 볼 수 있지만 그렇게 어렵지 않아

Let's breifly talk about some of the other concrete gestures beside pan,

팬 말고도 불연속적인 제스처에 대해서 간단히 이야기해보자

there's pinces, pinches is two fingers down pinching in and out like this.

제스처에는 핀치가 있어. 핀치는 두개의 손가락으로 꼬집은 모양을 하는거야

Okay? And here, what you're getting instead of the translation is the scale

여기서는 이동거리말고 비율을 받을 수 있어

so if I start my fingers here, and I bring them out twice as wide,

따라서 내가 여기서 손가락을 시작해서, 2배까지 움직인다면

that would be a scale of two

2배의 비율이 되겠지

if started here moving in halfway, that a scale .5.

만약 손가락을 반만큼으로 줄인다면, 0.5배가 될거야

So I'm scaling whatever on my screen, and again I can get velocity.

그래서 나는 화면위에 있는것의 비율을 조정하고, 팬과 마찬가지로 속력을 구할 수 있어

How fast I'm pinching. Rotation is two fingers turning them okay?

얼마나 빨리 핀치하는지. 회전은 두개의 손가락을 돌리는 제스처야

Like you're turning a knob and it'll tell you how many radians you've turned.

문고리를 돌리는것 처럼. 그리고 몇 라디안이나 회전했는지 알려줄꺼야

And again, velocity, how fast you're turning.

그리고 여기도 마찬가리고 속력. 얼마나 빨리 회전하고 있는지.

Swipe gesutre, okay? The swipe gesture usually have to configure before you use it.

스와이프 제스처. 스와이프 제스처는 일반적으로 사용하기 전에 설정을 해줘야해

You have to say you want a left going swipe, right going swipe, swipe up or down.

왼쪽, 오른쪽, 위, 아래의 스와이프를 인식할건지 미리 설정을 해줘야해

And also two fingers swipe or one finger, or three fingers.

그리고 또 두손가락인지, 한손가락인지, 아니면 세손가락인지

You have to configure that, and then you add the gesture recognizer

이 설정들을 모두 마치고, GestureRecognizer를 더하는데

and it will only recognize it if all those things are true.

설정에서 참이라고 한 값들만 인식하게 될꺼야.

Two finger, swipe up.

예를 들어 2개의 손가락으로 위로 스와이프라든지 말이야

Past all the has to be two-finger swipe up otherwise it doesn't recognize it.

2개의 손가락으로 위로 스와이프가 아니라면 인식하지 못할거야

That's swipe.

이게 스와이프고

Tap which seems like it would be discreet, but is not quite a discreet gesture.

탭은 얼핏 보기에는 불연속적인 제스처같지만, 사실은 아니야

But you also configure it with how many taps was it a single tap, or a double tap

얼마나 탭을 여러번 했는지를 설정할 수 있지. 한번 탭 했는가, 혹은 두번 탭했는가.

and two fingers or one.

그리고 2개의 손가락인지 하나인지

And here, you're going to look for .Ended to find out when the tap has happened. Okay?

그리고 여기에선 탭이 언제 발생했는지를 알려면 .Ended 상태를 찾아야해

That's because a tap actually has intermediate things going on like a Double tap.

왜냐하면 탭은 사실 더블탭의 일부가 될수도 있기 때문이지

The first tap and then the second tap

첫번째 탭 그리고 두번째 탭이 필요하기 때문이야

and it might go through a state change that will call your handler but it's not done yet. Okay?

핸들러를 호출하게 되는 상태변화를 겪을지 몰라도 탭이 완전히 끝난건 아니야

And you can't look at recognized that recognized with tap because it's not discrete gesture

그리고 탭에는 .Recognized를 확인할 수도 없는게 탭은 불연속적이지 않기 때문이지

becaus eit goes through those intermediate phases. So you will look for .Ended with tap. Okay?

왜냐하면 중간 단계를 거치기 때문에야. 따라서 탭은 .Ended로 확인할 수 있어.
